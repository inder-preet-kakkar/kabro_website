<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.353">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-12-11">

<title>Inder Preet - NeurIPS 2025 Takeaways</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Inder Preet</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../portfolio.html" rel="" target="">
 <span class="menu-text">Portfolio</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../blog.html" rel="" target="">
 <span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../media.html" rel="" target="">
 <span class="menu-text">Publications</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title"><b>NeurIPS 2025 Takeaways</b></h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 11, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>It was my first time attending NeurIPS, and it was quite something—to see so many people whose papers you’ve read and whose work you’ve admired, all together under the same roof. It genuinely felt like being in the driver’s seat of the AI buzz we’re going through. So, I have put together a few takeaways from the conference that I would like to share.</p>
<section id="benchmarks-for-agents-and-beyond" class="level2">
<h2 class="anchored" data-anchor-id="benchmarks-for-agents-and-beyond">Benchmarks for agents and beyond</h2>
<p>The very first day was quite interesting with a lot of contrasting ideas. The very first talk was from Apple, checkout their paper “The Illusion of Thinking” for more background, but the crux of it was how reasoning models performed beyond benchmarks. In their study, they showed how reasoning models behave at games like Towers of Hanoi, Checkers jumping, etc. And discovered something counter-intuitive: at low-complexity games, non-reasoning models perform the same as reasoning models; at medium complexity, reasoning models are better; but at high complexity, both are bad, despite increasing the thinking budget. And, quite interestingly, the number of thinking tokens also does not increase indefinitely; it plateaus once complexity is high enough. The point the sudy made is that performance of reasoning models which are considered to be state-of-the-art for LLMs is severley constrained.</p>
<p>But the same day there was an extensive tutorial on benchmarks, including a very interesting panel discussion with panelists from public-policy ,<a href="https://metr.org/">Meter</a>, creators of <a href="https://www.swebench.com/">SWE Bench</a> the coding benchmark, and a few more. It was an extensive disucssion but the following two have stuck with me:</p>
<ol type="1">
<li>It is tricky to talk about creating a benchmark. Some have stood the test of time—or, as someone said, are being used far beyond where they <em>should</em> be.</li>
<li>The panelist from Meter also expressed some displeasure about ‘exotic’ benchmarks like ARC-AGI, which he claimed (I’m paraphrasing) do not correspond to real-world applications and are instead someone’s idea of what intelligence <em>could</em> be—spatial reasoning in this case. I have often, been annoyed preparing for these exams that give you riddles testing what they call spatio-temporal <strong>reasoning</strong>. Is that real intelligence? Is that even a good proxy?</li>
</ol>
<p>That inevitably made me think of the Apple talk in the morning, which now also seemed like an ‘exotic’ game chosen as a proxy for intelligence. The authors were aware of this and have responded to critics, but the justification felt less convincing when viewed from this angle. The strategy seems to be: choose a game the LLMs have likely never seen during training and then extrapolate performance there to draw conclusions about general reasoning capabilities. But yes, I do understand that intelligence itself is an ill-defined concept and this evaluation problem will always be slippery. Nevertheless, these studies and ‘exotic datasets’ are interesting because they shed light on new domains for LLMs and who knows where the next breakthrough comes from.</p>
<p>Apart from these highly philosophical discussions, there were some very practical trends around benchmarking agents. We are all aware of the limitations of traditional metrics, the overly homogeneous test sets, data drift, and so on. But a new, dynamic testing framework is emerging with agents: generating new test instances during evaluation, keeping the test set alive instead of static. The key metric becomes whether the agent accomplishes the task, however you want to quantify that, instead of the accuracy of components like word-error rate or F1 score. A clear shift from what I’d call <em>academic</em> metrics to more product-centric ones—nobody should be unhappy about that. One of the best examples came at the end of the day from Tesla’s driving agent. They built a world model from the millions of miles of driving data they have, and they can edit the inputs to this world model using natural language to create new scenarios on the road to test their self-driving agent. A closed-loop simulator for testing <em>and</em> training agents. Honestly the best production-grade example I saw.</p>
<p>BeeAI framework from IBM also fits neatly into this new paradigm of dynamic evaluation, though I’ll write more on that separately.</p>
</section>
<section id="coding-agents" class="level2">
<h2 class="anchored" data-anchor-id="coding-agents">Coding agents</h2>
<p>Research and industry both recognize the limitations of current coding agents when it comes to production-quality code. Everyone acknowledges the issues with SWE-bench, and they admit that getting real production data for coding benchmarks is still a major bottleneck. If that’s the bottleneck, then are we just one step away from Microsoft (owning GitHub) or Google—with their armies of engineers locking down the advantage? Maybe. But Claude Code doing extremely well keeps me hopeful that we’ll see meaningful competition rather than consolidation.</p>
<p>I see a new trend emergin as well, a huge proportion of papers on coding agents revolve around clever prompting strategies and decomposing problems into flows that <em>might</em> help the agent. But isn’t that just what all of us do anyway? You sketch a high-level plan before solving anything. It reminds me of a few years ago when ML use exploded and thousands of papers emerged where people applied standard ML techniques to a new domain, and master’s theses consisted of doing a giant grid search. Mine was the same, by the way ;)</p>
<p>A cute piece of work was <a href="https://github.com/going-doer/Paper2Code">Paper2Code</a> which talks about the forever needed task of generating code from research papers to replicate their studies or buidl them further. Something we’ve all desperately needed, so kudos to them.</p>
<p>IBM’s <a href="https://research.ibm.com/blog/project-alice-software-bugs-agents">ALICE</a> - Agentic Logic for Incident and Code bug Elimination, is another one I’m proud to see progress. ALICE brings together multi-agent collaboration, incident analysis, and code-level reasoning to help teams diagnose complex system issues faster and more intelligently. This sits right at the intersection of AI agents, observability, and software automation—an area that’s evolving ridiculously fast, and I’m grateful to be contributing to it.</p>
</section>
<section id="efficient-ai" class="level2">
<h2 class="anchored" data-anchor-id="efficient-ai">Efficient AI</h2>
<p>There was a lot happening on Efficient AI. The most intriguing work was from companies like <a href="https://www.eigenai.com/">Eigen AI</a>, <a href="https://www.pruna.ai/">Pruna AI</a>, <a href="https://furiosa.ai/">Furiosa AI</a>, and <a href="https://www.qualcomm.com/">Qualcomm</a> (check out their demo on disaggregated LLM serving on AI accelerators). A lot of practical solutions for energy saving, compute optimization are finally making their way into the market with an ever crunching demand for chips.</p>
<p>As usual <a href="https://hanlab.mit.edu/">Han Lab</a> stood out with: <strong>Jet-Nemotron</strong> and <strong>radial attention</strong>—a sparse attention mechanism for long video generation. Sparse models are clearly becoming the theme again, but this time in they are expanding into other modalities as well.</p>
</section>
<section id="wrapping-up" class="level2">
<h2 class="anchored" data-anchor-id="wrapping-up">Wrapping up</h2>
<p>As always, a lot of the best parts of NeurIPS happen outside the sessions. The side conversations were rich, people comparing notes on agent evaluations, debugging LLM behaviors in the wild, trying to make sense of the rapid shifts in hardware, and the shared feeling that we’re building tools faster than we can define what “good” looks like. It’s chaotic, but in the fun way.</p>
<p>And yes, I left with more questions than answers, but that’s the whole point of going.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="inder-preet-kakkar/website_comments" data-repo-id="R_kgDOKBYtNQ" data-category="General" data-category-id="DIC_kwDOKBYtNc4CYOhM" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->



</body></html>